<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive Player</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1e2936">
    <link rel="apple-touch-icon" href="research_archive.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f1419;
            color: #e1e5e9;
            padding: 20px;
            line-height: 1.6;
        }
        
        h1 {
            margin-bottom: 30px;
            text-align: center;
            color: #e1e5e9;
        }
        
        .track-row {
            background: #1e2936;
            border: 1px solid #2d3748;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: opacity 0.3s, background 0.2s;
        }
        
        .track-row:hover {
            background: #233142;
        }
        
        .track-title {
            font-weight: 600;
            color: #e1e5e9;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .progress-container {
            width: 100%;
            display: none;
            margin-bottom: 10px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #2d3748;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4299e1, #63b3ed);
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s;
        }
        
        .progress-time {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #a0aec0;
            margin-top: 5px;
        }
        
        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: #2d3748;
            color: #e1e5e9;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s, transform 0.1s;
        }
        
        button:hover {
            background: #4a5568;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #1a202c;
            color: #718096;
            cursor: not-allowed;
            transform: none;
        }
        
        .play-btn {
            background: #38a169;
            font-weight: bold;
        }
        
        .play-btn:hover {
            background: #48bb78;
        }
        
        .pause-btn {
            background: #e53e3e;
            font-weight: bold;
        }
        
        .pause-btn:hover {
            background: #f56565;
        }
        
        .download-btn {
            background: #3182ce;
        }
        
        .download-btn:hover {
            background: #4299e1;
        }
        
        .downloaded {
            background: #38a169 !important;
            opacity: 0.8;
        }
        
        .listened-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #4299e1;
        }
        
        .listened-indicator {
            color: #f6ad55;
            font-weight: bold;
            display: none;
        }
        
        .no-tracks {
            text-align: center;
            color: #718096;
            padding: 40px;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            color: #e1e5e9;
            padding: 20px;
        }
    </style>
</head>
<body>
    <h1>Archive Player</h1>
    <div id="loading" class="loading">Loading tracks...</div>
    <div id="tracks-container"></div>
    <div id="no-tracks" class="no-tracks" style="display: none;">
        No MP3 links found. The app will automatically discover audio files from your podcast pages.
    </div>

    <script>
        class AudioPlayerApp {
            constructor() {
                this.tracks = [];
                this.currentTrack = null;
                this.audio = null;
                this.db = null;
                this.progressInterval = null;
            }

            async init() {
                document.getElementById('loading').style.display = 'block';
                await this.initDB();
                await this.scanForMp3Links();
                await this.loadStoredData();
                this.setupUI();
                document.getElementById('loading').style.display = 'none';
            }

            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('KurdishAudioDB', 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Store track metadata and listening status
                        if (!db.objectStoreNames.contains('tracks')) {
                            const trackStore = db.createObjectStore('tracks', { keyPath: 'id' });
                            trackStore.createIndex('url', 'url', { unique: true });
                        }
                        
                        // Store actual audio file data
                        if (!db.objectStoreNames.contains('audioFiles')) {
                            db.createObjectStore('audioFiles', { keyPath: 'url' });
                        }
                    };
                });
            }

            async saveTrackData(track) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['tracks'], 'readwrite');
                    const store = transaction.objectStore('tracks');
                    const request = store.put(track);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getTrackData(trackId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['tracks'], 'readonly');
                    const store = transaction.objectStore('tracks');
                    const request = store.get(trackId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveAudioFile(url, arrayBuffer) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['audioFiles'], 'readwrite');
                    const store = transaction.objectStore('audioFiles');
                    const request = store.put({ url, data: arrayBuffer, savedAt: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getAudioFile(url) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['audioFiles'], 'readonly');
                    const store = transaction.objectStore('audioFiles');
                    const request = store.get(url);
                    request.onsuccess = () => resolve(request.result ? request.result.data : null);
                    request.onerror = () => reject(request.error);
                });
            }

            async loadStoredData() {
                try {
                    const transaction = this.db.transaction(['tracks'], 'readonly');
                    const store = transaction.objectStore('tracks');
                    
                    return new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => {
                            const allTracks = request.result || [];
                            
                            // Update tracks with stored data
                            this.tracks.forEach(track => {
                                const stored = allTracks.find(t => t.url === track.url);
                                if (stored) {
                                    track.listened = stored.listened;
                                    track.downloaded = stored.downloaded;
                                    track.lastPlayed = stored.lastPlayed;
                                }
                            });
                            resolve();
                        };
                        request.onerror = () => {
                            console.log('Failed to load stored data, continuing anyway');
                            resolve(); // Don't fail the whole app
                        };
                    });
                } catch (error) {
                    console.log('IndexedDB error, continuing without stored data:', error);
                }
            }

            async scanForMp3Links() {
                const foundTracks = new Map();
                let trackId = 0;
                let htmlFiles = [];

                // Method 1: Try directory listing (works locally)
                try {
                    console.log('Attempting directory listing...');
                    const dirResponse = await fetch('../podcast_pages/');
                    if (dirResponse.ok) {
                        const dirHtml = await dirResponse.text();
                        const fileMatches = dirHtml.match(/href="[^"]*\.html"/g);
                        if (fileMatches && fileMatches.length > 0) {
                            htmlFiles = fileMatches.map(match => {
                                const fullPath = match.slice(6, -1);
                                return fullPath.split('/').pop();
                            });
                            console.log(`Directory listing found ${htmlFiles.length} files`);
                        }
                    }
                } catch (error) {
                    console.log('Directory listing failed:', error.message);
                }

                // Method 2: If directory listing failed, try sitemap approach
                if (htmlFiles.length === 0) {
                    try {
                        console.log('Trying sitemap/robots approach...');
                        // Try to fetch a known file and extract links from it
                        const indexResponse = await fetch('../../landing_pages/kurdish_research.html');
                        if (indexResponse.ok) {
                            const indexHtml = await indexResponse.text();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(indexHtml, 'text/html');
                            
                            // Look for links to podcast pages
                            const links = doc.querySelectorAll('a[href*="podcast_pages/"]');
                            htmlFiles = Array.from(links).map(link => {
                                const href = link.getAttribute('href');
                                return href.split('/').pop();
                            }).filter(file => file.endsWith('.html'));
                            
                            console.log(`Found ${htmlFiles.length} files from index page`);
                        }
                    } catch (error) {
                        console.log('Index page method failed:', error.message);
                    }
                }

                // Method 3: Brute force common patterns (last resort)
                if (htmlFiles.length === 0) {
                    console.log('Trying brute force discovery...');
                    const commonFiles = [
                        'Afrin_-_Kilis_Relations.html',
                        'Afrin_Alevis_Before_2010.html',
                        'Afrin_and_Cyrrhestica_in_Roman_Times.html',
                        'Afrin_Architecture.html',
                        'Afrin_during_the_Muslim_Conquest.html'
                    ];
                    
                    // Test if any exist
                    for (const testFile of commonFiles) {
                        try {
                            const testResponse = await fetch(`../podcast_pages/${testFile}`, { method: 'HEAD' });
                            if (testResponse.ok) {
                                htmlFiles.push(testFile);
                            }
                        } catch (error) {
                            // Ignore failures
                        }
                    }
                    console.log(`Brute force found ${htmlFiles.length} files`);
                }

                if (htmlFiles.length === 0) {
                    console.log('NO FILES FOUND - All discovery methods failed');
                    return;
                }

                console.log(`Scanning ${htmlFiles.length} files for MP3s...`);
                
                // Scan each discovered file for MP3s
                for (const fileName of htmlFiles) {
                    try {
                        const pageResponse = await fetch(`../podcast_pages/${fileName}`);
                        if (pageResponse.ok) {
                            const pageHtml = await pageResponse.text();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(pageHtml, 'text/html');
                            
                            // Get page title
                            const pageTitle = doc.title || fileName.replace('.html', '').replace(/_/g, ' ');
                            
                            // Find MP3 references - both audio sources and download links
                            const audioSources = doc.querySelectorAll('source[src$=".mp3"]');
                            const downloadLinks = doc.querySelectorAll('a[href$=".mp3"][download]');
                            
                            [...audioSources, ...downloadLinks].forEach(element => {
                                const url = element.src || element.href;
                                if (url && !foundTracks.has(url)) {
                                    foundTracks.set(url, {
                                        id: trackId++,
                                        url: url,
                                        title: pageTitle,
                                        downloaded: false,
                                        listened: false
                                    });
                                }
                            });
                            
                            if (audioSources.length > 0 || downloadLinks.length > 0) {
                                console.log(`${fileName}: found MP3`);
                            }
                        } else {
                            console.log(`${fileName}: HTTP ${pageResponse.status}`);
                        }
                    } catch (error) {
                        console.log(`${fileName}: ${error.message}`);
                    }
                }

                this.tracks = Array.from(foundTracks.values());
                console.log(`FINAL RESULT: ${this.tracks.length} audio tracks found`);
            }

            setupUI() {
                const container = document.getElementById('tracks-container');
                const noTracksDiv = document.getElementById('no-tracks');
                
                if (this.tracks.length === 0) {
                    noTracksDiv.style.display = 'block';
                    return;
                }

                container.innerHTML = this.tracks.map(track => `
                    <div class="track-row" data-track-id="${track.id}">
                        <div class="track-title">${track.title} <span class="listened-indicator">Listened</span></div>
                        <div class="progress-container" data-progress-container="${track.id}">
                            <div class="progress-bar" data-progress-bar="${track.id}">
                                <div class="progress-fill" data-progress-fill="${track.id}"></div>
                            </div>
                            <div class="progress-time" data-progress-time="${track.id}">
                                <span>0:00</span>
                                <span>0:00</span>
                            </div>
                        </div>
                        <div class="controls">
                            <button class="play-btn" data-play="${track.id}">Play</button>
                            <button class="pause-btn" data-pause="${track.id}" style="display: none;">⏸ Pause</button>
                            <button data-rewind="${track.id}">-10 <<</button>
                            <button data-forward="${track.id}">>> +10</button>
                            <button data-download="${track.id}">Download</button>
                            <label class="listened-container">
                                <input type="checkbox" data-listened="${track.id}" ${track.listened ? 'checked' : ''}> 
                                Listened
                            </label>
                        </div>
                    </div>
                `).join('');

                // Add event listeners
                container.addEventListener('click', (e) => {
                    const playBtn = e.target.closest('[data-play]');
                    const pauseBtn = e.target.closest('[data-pause]');
                    const downloadBtn = e.target.closest('[data-download]');
                    const listenedCheckbox = e.target.closest('[data-listened]');
                    const rewindBtn = e.target.closest('[data-rewind]');
                    const forwardBtn = e.target.closest('[data-forward]');
                    const progressBar = e.target.closest('[data-progress-bar]');

                    if (playBtn) {
                        const trackId = parseInt(playBtn.dataset.play);
                        this.playTrack(trackId);
                    } else if (pauseBtn) {
                        const trackId = parseInt(pauseBtn.dataset.pause);
                        this.pauseTrack(trackId);
                    } else if (downloadBtn) {
                        const trackId = parseInt(downloadBtn.dataset.download);
                        this.downloadTrack(trackId);
                    } else if (listenedCheckbox) {
                        const trackId = parseInt(listenedCheckbox.dataset.listened);
                        this.markAsListened(trackId, listenedCheckbox.checked);
                    } else if (rewindBtn) {
                        const trackId = parseInt(rewindBtn.dataset.rewind);
                        this.rewind(trackId);
                    } else if (forwardBtn) {
                        const trackId = parseInt(forwardBtn.dataset.forward);
                        this.fastForward(trackId);
                    } else if (progressBar) {
                        const trackId = parseInt(progressBar.dataset.progressBar);
                        this.seekTo(trackId, e);
                    }
                });

                // Update display for already listened/downloaded tracks
                this.tracks.forEach(track => {
                    this.updateTrackDisplay(track);
                });
            }

            seekTo(trackId, event) {
                if (this.audio && this.currentTrack && this.currentTrack.id === trackId) {
                    const progressBar = event.currentTarget;
                    const rect = progressBar.getBoundingClientRect();
                    const percentage = (event.clientX - rect.left) / rect.width;
                    const newTime = percentage * this.audio.duration;
                    
                    if (!isNaN(newTime)) {
                        this.audio.currentTime = newTime;
                    }
                }
            }

            updateProgress() {
                if (!this.audio || !this.currentTrack) return;

                const trackId = this.currentTrack.id;
                const progressFill = document.querySelector(`[data-progress-fill="${trackId}"]`);
                const progressTime = document.querySelector(`[data-progress-time="${trackId}"]`);
                
                if (progressFill && progressTime && this.audio.duration) {
                    const percentage = (this.audio.currentTime / this.audio.duration) * 100;
                    progressFill.style.width = `${percentage}%`;
                    
                    const currentTime = this.formatTime(this.audio.currentTime);
                    const totalTime = this.formatTime(this.audio.duration);
                    progressTime.innerHTML = `<span>${currentTime}</span><span>${totalTime}</span>`;
                }
            }

            formatTime(seconds) {
                if (!seconds || isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            async downloadTrack(trackId) {
                const track = this.tracks.find(t => t.id === trackId);
                if (!track) return;

                const button = document.querySelector(`[data-download="${trackId}"]`);
                button.textContent = 'Downloading...';
                button.disabled = true;

                try {
                    // Check if already downloaded
                    const cachedFile = await this.getAudioFile(track.url);
                    if (cachedFile) {
                        track.downloaded = true;
                        await this.saveTrackData(track);
                        button.textContent = 'Downloaded';
                        this.updateTrackDisplay(track);
                        return;
                    }

                    // Download the file
                    const response = await fetch(track.url);
                    const arrayBuffer = await response.arrayBuffer();
                    
                    // Save to IndexedDB
                    await this.saveAudioFile(track.url, arrayBuffer);
                    
                    track.downloaded = true;
                    await this.saveTrackData(track);
                    
                    button.textContent = 'Downloaded';
                    this.updateTrackDisplay(track);
                    
                } catch (error) {
                    console.error('Download failed:', error);
                    button.textContent = 'Download Failed';
                    setTimeout(() => {
                        button.textContent = 'Download';
                        button.disabled = false;
                    }, 2000);
                }
            }

            async playTrack(trackId) {
                const track = this.tracks.find(t => t.id === trackId);
                if (!track) return;

                // Stop current audio if playing
                if (this.audio) {
                    this.audio.pause();
                    this.stopProgressUpdate();
                    this.hideAllProgressBars();
                    this.resetAllButtons();
                }

                try {
                    // Try to use downloaded file first
                    const cachedFile = await this.getAudioFile(track.url);
                    let audioSrc;
                    
                    if (cachedFile) {
                        // Use downloaded file
                        const blob = new Blob([cachedFile], { type: 'audio/mpeg' });
                        audioSrc = URL.createObjectURL(blob);
                    } else {
                        // Stream from network
                        audioSrc = track.url;
                    }

                    this.audio = new Audio(audioSrc);
                    this.currentTrack = track;
                    
                    this.audio.addEventListener('ended', () => {
                        this.markAsListened(trackId, true);
                        this.resetAllButtons();
                        this.hideAllProgressBars();
                        this.stopProgressUpdate();
                    });
                    
                    this.audio.addEventListener('error', (e) => {
                        console.error('Audio playback failed:', e);
                        alert('Playback failed. File may not be downloaded for offline use.');
                        this.resetAllButtons();
                    });

                    this.audio.addEventListener('loadedmetadata', () => {
                        this.updateProgress();
                    });

                    await this.audio.play();
                    this.showProgressBar(trackId);
                    this.updatePlayButton(trackId);
                    this.startProgressUpdate();
                    
                } catch (error) {
                    console.error('Playback failed:', error);
                    alert('Playback failed. Check if file is downloaded for offline use.');
                    this.resetAllButtons();
                }
            }

            pauseTrack(trackId) {
                if (this.audio && this.currentTrack && this.currentTrack.id === trackId) {
                    this.audio.pause();
                    this.stopProgressUpdate();
                    this.resetAllButtons();
                }
            }

            showProgressBar(trackId) {
                this.hideAllProgressBars();
                const progressContainer = document.querySelector(`[data-progress-container="${trackId}"]`);
                if (progressContainer) {
                    progressContainer.style.display = 'block';
                }
            }

            hideAllProgressBars() {
                document.querySelectorAll('[data-progress-container]').forEach(container => {
                    container.style.display = 'none';
                });
            }

            updatePlayButton(trackId) {
                this.resetAllButtons();
                const playBtn = document.querySelector(`[data-play="${trackId}"]`);
                const pauseBtn = document.querySelector(`[data-pause="${trackId}"]`);
                
                if (playBtn && pauseBtn) {
                    playBtn.style.display = 'none';
                    pauseBtn.style.display = 'inline-block';
                }
            }

            resetAllButtons() {
                document.querySelectorAll('[data-play]').forEach(btn => {
                    btn.style.display = 'inline-block';
                });
                document.querySelectorAll('[data-pause]').forEach(btn => {
                    btn.style.display = 'none';
                });
            }

            startProgressUpdate() {
                this.stopProgressUpdate();
                this.progressInterval = setInterval(() => {
                    this.updateProgress();
                }, 100);
            }

            stopProgressUpdate() {
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
            }

            rewind(trackId) {
                if (this.audio && this.currentTrack && this.currentTrack.id === trackId) {
                    this.audio.currentTime = Math.max(0, this.audio.currentTime - 10);
                }
            }

            fastForward(trackId) {
                if (this.audio && this.currentTrack && this.currentTrack.id === trackId) {
                    this.audio.currentTime = Math.min(this.audio.duration, this.audio.currentTime + 10);
                }
            }

            async markAsListened(trackId, listened) {
                const track = this.tracks.find(t => t.id === trackId);
                if (!track) return;

                track.listened = listened;
                if (listened) {
                    track.lastPlayed = new Date().toISOString();
                }
                
                await this.saveTrackData(track);
                this.updateTrackDisplay(track);
            }

            updateTrackDisplay(track) {
                const trackElement = document.querySelector(`[data-track-id="${track.id}"]`);
                if (!trackElement) return;

                const listenedIndicator = trackElement.querySelector('.listened-indicator');
                const downloadButton = trackElement.querySelector(`[data-download="${track.id}"]`);
                const checkbox = trackElement.querySelector(`[data-listened="${track.id}"]`);
                
                if (track.listened) {
                    listenedIndicator.style.display = 'inline';
                    trackElement.style.opacity = '0.7';
                    checkbox.checked = true;
                }
                
                if (track.downloaded) {
                    downloadButton.textContent = 'Downloaded';
                    downloadButton.disabled = true;
                    downloadButton.classList.add('downloaded');
                }
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            // Register service worker for offline functionality
            if ('serviceWorker' in navigator) {
                try {
                    await navigator.serviceWorker.register('sw.js');
                    console.log('Service Worker registered for offline support!');
                } catch (error) {
                    console.log('Service Worker registration failed:', error);
                }
            }

            // Initialize the audio player app
            window.audioApp = new AudioPlayerApp();
            await window.audioApp.init();
        });
    </script>
</body>
</html>