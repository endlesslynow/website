<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kurdish Research Audio Player</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2c3e50">
    <link rel="apple-touch-icon" href="research_archive.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #121212;
            color: #ffffff;
            padding: 20px;
            line-height: 1.6;
        }
        
        h1 {
            margin-bottom: 30px;
            text-align: center;
            color: #ffffff;
        }
        
        .track-row {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s;
        }
        
        .track-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: #333;
            color: #ffffff;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #444;
        }
        
        button:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
        }
        
        .play-btn {
            background: #4CAF50;
            font-weight: bold;
        }
        
        .play-btn:hover {
            background: #45a049;
        }
        
        .download-btn {
            background: #2196F3;
        }
        
        .download-btn:hover {
            background: #1976D2;
        }
        
        .downloaded {
            background: #27ae60 !important;
            opacity: 0.8;
        }
        
        .listened-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .listened-indicator {
            color: #f39c12;
            font-weight: bold;
            display: none;
        }
        
        .offline-indicator {
            color: #27ae60;
            font-size: 12px;
            margin-left: 10px;
            font-weight: bold;
        }
        
        .now-playing {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            padding: 15px;
            display: none;
            align-items: center;
            gap: 10px;
        }
        
        .no-tracks {
            text-align: center;
            color: #666;
            padding: 40px;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            color: #fff;
            padding: 20px;
        }
    </style>
</head>
<body>
    <h1>üéµ Kurdish Research Audio Player</h1>
    <div id="loading" class="loading">Loading tracks...</div>
    <div id="tracks-container"></div>
    <div id="no-tracks" class="no-tracks" style="display: none;">
        No MP3 links found. The app will automatically discover audio files from your podcast pages.
    </div>
    
    <div id="now-playing" class="now-playing">
        <div id="now-playing-info">Now Playing: </div>
        <button onclick="audioApp.pauseCurrentTrack()">‚è∏ Pause</button>
    </div>

    <script>
        class AudioPlayerApp {
            constructor() {
                this.tracks = [];
                this.currentTrack = null;
                this.audio = null;
                this.db = null;
            }

            async init() {
                document.getElementById('loading').style.display = 'block';
                await this.initDB();
                await this.scanForMp3Links();
                await this.loadStoredData();
                this.setupUI();
                document.getElementById('loading').style.display = 'none';
            }

            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('KurdishAudioDB', 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Store track metadata and listening status
                        if (!db.objectStoreNames.contains('tracks')) {
                            const trackStore = db.createObjectStore('tracks', { keyPath: 'id' });
                            trackStore.createIndex('url', 'url', { unique: true });
                        }
                        
                        // Store actual audio file data
                        if (!db.objectStoreNames.contains('audioFiles')) {
                            db.createObjectStore('audioFiles', { keyPath: 'url' });
                        }
                    };
                });
            }

            async saveTrackData(track) {
                const transaction = this.db.transaction(['tracks'], 'readwrite');
                const store = transaction.objectStore('tracks');
                await store.put(track);
            }

            async getTrackData(trackId) {
                const transaction = this.db.transaction(['tracks'], 'readonly');
                const store = transaction.objectStore('tracks');
                return await store.get(trackId);
            }

            async saveAudioFile(url, arrayBuffer) {
                const transaction = this.db.transaction(['audioFiles'], 'readwrite');
                const store = transaction.objectStore('audioFiles');
                await store.put({ url, data: arrayBuffer, savedAt: Date.now() });
            }

            async getAudioFile(url) {
                const transaction = this.db.transaction(['audioFiles'], 'readonly');
                const store = transaction.objectStore('audioFiles');
                const result = await store.get(url);
                return result ? result.data : null;
            }

            async loadStoredData() {
                const transaction = this.db.transaction(['tracks'], 'readonly');
                const store = transaction.objectStore('tracks');
                const allTracks = await store.getAll();
                
                // Update tracks with stored data
                this.tracks.forEach(track => {
                    const stored = allTracks.find(t => t.url === track.url);
                    if (stored) {
                        track.listened = stored.listened;
                        track.downloaded = stored.downloaded;
                        track.lastPlayed = stored.lastPlayed;
                    }
                });
            }

            async scanForMp3Links() {
                const foundTracks = new Map();
                let trackId = 0;
                let htmlFiles = [];

                // Method 1: Try directory listing (works locally)
                try {
                    console.log('üîç Attempting directory listing...');
                    const dirResponse = await fetch('../podcast_pages/');
                    if (dirResponse.ok) {
                        const dirHtml = await dirResponse.text();
                        const fileMatches = dirHtml.match(/href="[^"]*\.html"/g);
                        if (fileMatches && fileMatches.length > 0) {
                            htmlFiles = fileMatches.map(match => {
                                const fullPath = match.slice(6, -1);
                                return fullPath.split('/').pop();
                            });
                            console.log(`‚úÖ Directory listing found ${htmlFiles.length} files`);
                        }
                    }
                } catch (error) {
                    console.log('‚ùå Directory listing failed:', error.message);
                }

                // Method 2: If directory listing failed, try sitemap approach
                if (htmlFiles.length === 0) {
                    try {
                        console.log('üîç Trying sitemap/robots approach...');
                        // Try to fetch a known file and extract links from it
                        const indexResponse = await fetch('../../landing_pages/kurdish_research.html');
                        if (indexResponse.ok) {
                            const indexHtml = await indexResponse.text();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(indexHtml, 'text/html');
                            
                            // Look for links to podcast pages
                            const links = doc.querySelectorAll('a[href*="podcast_pages/"]');
                            htmlFiles = Array.from(links).map(link => {
                                const href = link.getAttribute('href');
                                return href.split('/').pop();
                            }).filter(file => file.endsWith('.html'));
                            
                            console.log(`‚úÖ Found ${htmlFiles.length} files from index page`);
                        }
                    } catch (error) {
                        console.log('‚ùå Index page method failed:', error.message);
                    }
                }

                // Method 3: Brute force common patterns (last resort)
                if (htmlFiles.length === 0) {
                    console.log('üîç Trying brute force discovery...');
                    const commonFiles = [
                        'Afrin_-_Kilis_Relations.html',
                        'Afrin_Alevis_Before_2010.html',
                        'Afrin_and_Cyrrhestica_in_Roman_Times.html',
                        'Afrin_Architecture.html',
                        'Afrin_during_the_Muslim_Conquest.html'
                    ];
                    
                    // Test if any exist
                    for (const testFile of commonFiles) {
                        try {
                            const testResponse = await fetch(`../podcast_pages/${testFile}`, { method: 'HEAD' });
                            if (testResponse.ok) {
                                htmlFiles.push(testFile);
                            }
                        } catch (error) {
                            // Ignore failures
                        }
                    }
                    console.log(`‚úÖ Brute force found ${htmlFiles.length} files`);
                }

                if (htmlFiles.length === 0) {
                    console.log('üö® NO FILES FOUND - All discovery methods failed');
                    return;
                }

                console.log(`üìä Scanning ${htmlFiles.length} files for MP3s...`);
                
                // Scan each discovered file for MP3s
                for (const fileName of htmlFiles) {
                    try {
                        const pageResponse = await fetch(`../podcast_pages/${fileName}`);
                        if (pageResponse.ok) {
                            const pageHtml = await pageResponse.text();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(pageHtml, 'text/html');
                            
                            // Get page title
                            const pageTitle = doc.title || fileName.replace('.html', '').replace(/_/g, ' ');
                            
                            // Find MP3 references - both audio sources and download links
                            const audioSources = doc.querySelectorAll('source[src$=".mp3"]');
                            const downloadLinks = doc.querySelectorAll('a[href$=".mp3"][download]');
                            
                            [...audioSources, ...downloadLinks].forEach(element => {
                                const url = element.src || element.href;
                                if (url && !foundTracks.has(url)) {
                                    foundTracks.set(url, {
                                        id: trackId++,
                                        url: url,
                                        title: pageTitle,
                                        downloaded: false,
                                        listened: false
                                    });
                                }
                            });
                            
                            if (audioSources.length > 0 || downloadLinks.length > 0) {
                                console.log(`‚úÖ ${fileName}: found MP3`);
                            }
                        } else {
                            console.log(`‚ùå ${fileName}: HTTP ${pageResponse.status}`);
                        }
                    } catch (error) {
                        console.log(`‚ùå ${fileName}: ${error.message}`);
                    }
                }

                this.tracks = Array.from(foundTracks.values());
                console.log(`üéµ FINAL RESULT: ${this.tracks.length} audio tracks found`);
            }

            setupUI() {
                const container = document.getElementById('tracks-container');
                const noTracksDiv = document.getElementById('no-tracks');
                
                if (this.tracks.length === 0) {
                    noTracksDiv.style.display = 'block';
                    return;
                }

                container.innerHTML = this.tracks.map(track => `
                    <div class="track-row" data-track-id="${track.id}">
                        <div class="track-title">${track.title} <span class="listened-indicator">‚úì Listened</span></div>
                        <div class="controls">
                            <button class="play-btn" data-play="${track.id}">‚ñ∂ Play</button>
                            <button data-download="${track.id}">‚Üì Download</button>
                            <label>
                                <input type="checkbox" data-listened="${track.id}" ${track.listened ? 'checked' : ''}> 
                                Listened
                            </label>
                        </div>
                    </div>
                `).join('');

                // Add event listeners
                container.addEventListener('click', (e) => {
                    const playBtn = e.target.closest('[data-play]');
                    const downloadBtn = e.target.closest('[data-download]');
                    const listenedCheckbox = e.target.closest('[data-listened]');

                    if (playBtn) {
                        const trackId = parseInt(playBtn.dataset.play);
                        this.playTrack(trackId);
                    } else if (downloadBtn) {
                        const trackId = parseInt(downloadBtn.dataset.download);
                        this.downloadTrack(trackId);
                    } else if (listenedCheckbox) {
                        const trackId = parseInt(listenedCheckbox.dataset.listened);
                        this.markAsListened(trackId, listenedCheckbox.checked);
                    }
                });

                // Update display for already listened/downloaded tracks
                this.tracks.forEach(track => {
                    this.updateTrackDisplay(track);
                });
            }

            async downloadTrack(trackId) {
                const track = this.tracks.find(t => t.id === trackId);
                if (!track) return;

                const button = document.querySelector(`[data-download="${trackId}"]`);
                button.textContent = 'Downloading...';
                button.disabled = true;

                try {
                    // Check if already downloaded
                    const cachedFile = await this.getAudioFile(track.url);
                    if (cachedFile) {
                        track.downloaded = true;
                        await this.saveTrackData(track);
                        button.textContent = '‚úì Downloaded';
                        this.updateTrackDisplay(track);
                        return;
                    }

                    // Download the file
                    const response = await fetch(track.url);
                    const arrayBuffer = await response.arrayBuffer();
                    
                    // Save to IndexedDB
                    await this.saveAudioFile(track.url, arrayBuffer);
                    
                    track.downloaded = true;
                    await this.saveTrackData(track);
                    
                    button.textContent = '‚úì Downloaded';
                    this.updateTrackDisplay(track);
                    
                } catch (error) {
                    console.error('Download failed:', error);
                    button.textContent = 'Download Failed';
                    setTimeout(() => {
                        button.textContent = '‚Üì Download';
                        button.disabled = false;
                    }, 2000);
                }
            }

            async playTrack(trackId) {
                const track = this.tracks.find(t => t.id === trackId);
                if (!track) return;

                // Stop current audio if playing
                if (this.audio) {
                    this.audio.pause();
                    this.audio = null;
                }

                try {
                    // Try to use downloaded file first
                    const cachedFile = await this.getAudioFile(track.url);
                    let audioSrc;
                    
                    if (cachedFile) {
                        // Use downloaded file
                        const blob = new Blob([cachedFile], { type: 'audio/mpeg' });
                        audioSrc = URL.createObjectURL(blob);
                    } else {
                        // Stream from network
                        audioSrc = track.url;
                    }

                    this.audio = new Audio(audioSrc);
                    this.currentTrack = track;
                    
                    this.audio.addEventListener('ended', () => {
                        this.markAsListened(trackId, true);
                    });
                    
                    this.audio.addEventListener('error', (e) => {
                        console.error('Audio playback failed:', e);
                        alert('Playback failed. File may not be downloaded for offline use.');
                    });

                    await this.audio.play();
                    this.showNowPlaying(track);
                    
                } catch (error) {
                    console.error('Playback failed:', error);
                    alert('Playback failed. Check if file is downloaded for offline use.');
                }
            }

            async markAsListened(trackId, listened) {
                const track = this.tracks.find(t => t.id === trackId);
                if (!track) return;

                track.listened = listened;
                if (listened) {
                    track.lastPlayed = new Date().toISOString();
                }
                
                await this.saveTrackData(track);
                this.updateTrackDisplay(track);
            }

            updateTrackDisplay(track) {
                const trackElement = document.querySelector(`[data-track-id="${track.id}"]`);
                if (!trackElement) return;

                const listenedIndicator = trackElement.querySelector('.listened-indicator');
                const downloadButton = trackElement.querySelector(`[data-download="${track.id}"]`);
                const checkbox = trackElement.querySelector(`[data-listened="${track.id}"]`);
                
                if (track.listened) {
                    listenedIndicator.style.display = 'inline';
                    trackElement.style.opacity = '0.7';
                    checkbox.checked = true;
                }
                
                if (track.downloaded) {
                    downloadButton.textContent = '‚úì Downloaded';
                    downloadButton.disabled = true;
                    downloadButton.style.background = '#27ae60';
                    
                    // Add offline indicator
                    const offlineIndicator = trackElement.querySelector('.offline-indicator') || 
                        document.createElement('span');
                    offlineIndicator.className = 'offline-indicator';
                    offlineIndicator.textContent = 'üì± Offline Ready';
                    
                    if (!trackElement.querySelector('.offline-indicator')) {
                        trackElement.appendChild(offlineIndicator);
                    }
                }
            }

            showNowPlaying(track) {
                const nowPlaying = document.getElementById('now-playing');
                const info = document.getElementById('now-playing-info');
                info.textContent = `Now Playing: ${track.title}`;
                nowPlaying.style.display = 'flex';
            }

            pauseCurrentTrack() {
                if (this.audio && !this.audio.paused) {
                    this.audio.pause();
                    document.getElementById('now-playing').style.display = 'none';
                }
            }
        }

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            // Register service worker for offline functionality
            if ('serviceWorker' in navigator) {
                try {
                    await navigator.serviceWorker.register('sw.js');
                    console.log('Service Worker registered for offline support!');
                } catch (error) {
                    console.log('Service Worker registration failed:', error);
                }
            }

            // Initialize the audio player app
            window.audioApp = new AudioPlayerApp();
            await window.audioApp.init();
        });
    </script>
</body>
</html>